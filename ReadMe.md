# 需求

可以外部、内部、TCP 呼叫电梯到达指定楼层。

- 外部的请求，需要区分上行/下行。电梯在当前楼层且方向匹配，才认为完成
- 内部的请求，不区分上行/下行；电梯到达顶层/底层后，清理所有内部任务（可配置）
- TCP 的请求，区分上行/下行，顶层/底层是否清理，需要允许配置

电梯到达指定楼层后，一定要开门。

电梯一定要先处理完当前楼层的任务，并且关门之后，再去其它楼层

电梯一定是单向的，比如先处理完比当前楼层高的上行任务，再处理下行的任务。不能来回走

门的状态，只维护梯厢。外部门与梯厢联动

防止并发问题

电梯速度、高度



**后续再说**
电梯组：在电梯厅中，按一个上行按钮，自动找到执行成本最小的一部电梯。合并多台电梯的外部请求

电梯分层停靠

电梯加速度。计算电梯楼层以及执行成本

优化电梯算法

每层的不同高度

# 实现

## 后端逻辑

电梯 runtime 维护下一个目标楼层 targetFloor

电梯上下行状态 liftState：上、下、空闲

门状态 doorState：open、opening、close、closing、error



**独立线程**（锁住当前电梯）

- 
- 清理原本运单
    - 外部请求：同楼层、同方向
    - 内部请求：所有
    - tcp 请求，定制
- 选更优的 targetFloor
    - 上行中的电梯，只能选比当前 height 高的任务
    - 下行中的电梯，只能选比当前 height 低的任务
    - 没有后续任务，清理 liftStatue、lifting
- 前往 targetFloor
    - 当前高度 + 本次打算移动高度是否大于目标楼层高度
        - 是：newHeight = targetFloor.height
        - 否：newHeight = oldHeight + step
    - ~~计算电梯当前高度、楼层、速度、加速度~~
    - ~~记录当前高度、速度、加速度~~
    - ~~此次移动后，是否到达目标楼层~~
        - ~~到达：高度不要超过目标楼层~~
        - ~~未到达：高度可以超过当前楼层~~
- 到达 targetFloor
    - 处理请求
        - 内部请求：清当前楼层、顶层/底层清全部
        - 外部请求：楼层、上下行状态匹配才清理。清理同电梯组组的状态
        - Tcp 请求：根据配置
    - 标记开门
- 处理门状态
    - 算是否开门完成
    - 算是否关门完成
    - 算是否要自动关门



**创建任务**：

- 内、外、tcp 任务，均直接加入到 tcp req 中

**关门**

- 如果当前机器人在移动，返回失败
- 标记关门

**查询机器人当前状态**



**配置**：

- 电梯 ID
- 总楼层，每层的 label (map)，每层高度
- 上升/下降一层楼需要的时间
- 开门关门需要的时间
- 开门维持的时间
  运行状态
- 电梯目前的目标楼层
    - 外部按的 -> 不显示在电梯内
    - 内部按的 + tcp 请求的 -> 显示在电梯内
- 电梯到达顶层、底层后，清理所有目标楼层



## 页面






~~请求的处理逻辑：~~
- ~~去指定楼层的请求，直接返回创建结果，异步处理~~
- ~~关门请求，直接返回请求结果，同步处理~~
- ~~到达 A 楼层后，处理所有 A 楼层的请求~~
- ~~要按照开始时间处理，不能每到一层楼重新计算~~
- ~~预留加速度、电梯高度~~

~~配置 + 运行状态模式~~

~~TCP Server~~

~~Handler~~
~~Http + websocket~~
- ~~电梯列表~~
    - ~~配置信息~~
    - ~~运行状态~~

~~任意请求电梯要到 A 层，~~
- ~~电梯靠近 A 层，可以在 A 层停下， 不考虑加速度~~
- ~~电梯远离 A 层，不在 A 层停。~~
- ~~电梯在 A 层，刷新维持开门的时间~~

~~业务逻辑：~~
- ~~电梯在目标楼层~~
    - ~~去掉所有此目标楼层的 req~~
- ~~不在目标楼层~~
    - ~~有更优的目标楼层~~
    - ~~没有更优的目标楼层~~
        - ~~前往目标楼层~~
